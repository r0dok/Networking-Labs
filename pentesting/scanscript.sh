#!/bin/bash
pentest="$1";
ips="$2";
timestamp=$(date "+%Y-%m-%d.%H:%M:%S");
parallelscans=5;
nmapratelimit="";

greeting() {
	echo "Welcome to the pentest initializer!";
}

usage() {
	echo "Usage: ./scansript.sh pentestname iprange";
}

purpose() {
	echo "This script generates a custom directory structure to retain overview over your pentest.";
}

# Create pentest, intel and targets directories if not yet present
createBaseDirs() {
	echo "Creating basic directory structure...";
	if [ ! -d $pentest ]; then
		mkdir $pentest;
		mkdir $pentest/targets;
		mkdir $pentest/intel;
	fi
	if [ ! -d $pentest/targets ]; then
		mkdir $pentest/targets;
	fi
	if [ ! -d $pentest/intel ]; then
		mkdir $pentest/intel;
	fi

}

#Host discovery scan with ICMP + TCP ping
hostDiscovery() {
	echo "Starting Host discovery scan on $ips..."
	iplist=$(nmap -sP $ips -oG - | tee "$pentest/targets/hosts-detected.$timestamp.txt" | grep "Status: Up" | cut -d" " -f2 | sed '/Nmap/d');
	echo "Hosts alive:"
	echo "$iplist";

	# If nbtscan has not yet been executed, execute it
	nbtscan -r "$ips" | tee "$pentest/targets/nbtscan.timestamp.txt";
}

# Merge discovered hosts files of previous host discoveries
mergeHostDiscoveries() {
	cat $pentest/targets/hosts-detected.*.txt | sort | uniq | cut -d" " -f2  | sed '/Nmap/d' > $pentest/targets/hosts-detected.txt;
}

# If ip has already been scanned, excluded it from iplist
#excludeScannedHosts() {
#	if [ -f $pentest/targets/$1/tcp-ports.txt ]; then
		#to be completed
#	fi
#}

# Create directories for hosts if they don't exist yet
createHostDir() {
	if [ ! -d $pentest/targets/$1 ]; then
		mkdir $pentest/targets/$1;
		# Dir for recon results
		if [ ! -d $pentest/targets/$1/infoDocs ]; then
			mkdir $pentest/targets/$1/infoDocs;
		fi
		# Dir for exploiting/screenshots etc
		if [ ! -d $pentest/targets/$1/auditLogs ]; then
			mkdir $pentest/targets/$1/auditLogs;
		fi
		# Dir for reporting
		if [ ! -d $pentest/targets/$1/reporting ]; then
			mkdir $pentest/targets/$1/reporting;
		fi
		# Dir for data exfil
		if [ ! -d $pentest/targets/$1/dataExtract ]; then
			mkdir $pentest/targets/$1/dataExtract;
		fi
	fi
}

# Generate directory per alive host
createHostDirs() {
	echo "Creating directories for every active host in $pentest/targets/..."
	for ip in $iplist;
	do
		createHostDir $ip;
	done
}

# @ minimal 1000 request/sec
# OS will also be guessed
# default nmap scripts will be ran against the target
executeTCPPortScan() {
	local RESULT=$(nmap -sT -sV -sC -O "$1" -p- --osscan-guess --reason $nmapratelimit -oX $pentest/targets/$ip/infoDocs/nmap-result.xml | tee "$pentest/targets/$ip/infoDocs/nmap-result.$timestamp.txt");
	echo "$1 scanned:"
	echo "$RESULT" | grep "open" | cut -d" " -f 1 | cut -d"/" -f1 | tee "$pentest/targets/$1/infoDocs/tcp-ports.txt";
}

# execute port and OS scan on every discovered host
executePortScans() {
	echo "executing extensive port scan..."
	for ip in $iplist; do
		# Allow max $parallelscans nmap scans to run concurrently
		# if less or equal than $parallelscans sub processes are running
		if [ $(jobs -l | wc -l) -lt $parallelscans ]; then
			# Start new subprocess
			echo "Scanning $ip...";
			executeTCPPortScan $ip &

			# Add pid of last created child process to the list
			pids="$pids $!"
		else
			# Wait until one of the subprocesses finishes
			wait -n $pids;

			# Rebuild pid list with current running subprocesses
			pids="";
			for job in $(jobs -p); do
				pids="$pids $job"
			done

			# Start new subprocess
			echo "Scanning $ip...";
			executeTCPPortScan $ip &

			# Add pid to the list
			pids="$pids $!"
		fi
	done
}

printScanMsg(){
	echo "Scanning $1 for $2 vulnerabilities...";
}

scanForSMTPVuln(){
	local smtp="smtp-commands.nse,smtp-enum-users.nse,smtp-ntlm-info.nse,smtp-open-relay.nse,smtp-strangeport.nse,smtp-vuln-cve2010-4344.nse,smtp-vuln-cve2011-1720.nse,smtp-vuln-cve2011-1764.nse";
	printScanMsg $1 $2
	nmap -p "$3" "$1" --script=$smtp $nmapratelimit | tee -a "$pentest/targets/$1/infoDocs/nmap-$2-$3.txt";
}

scanForSAMBAVuln(){
	printScanMsg $1 $2
	smbclient -L $1 | tee -a "$pentest/targets/$1/infoDocs/smbclient.txt";
}

# Credits to Stefan Hesselman for the idea
scanForSMBVuln(){
	local smb="smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse";
	printScanMsg $1 $2
	nmap -p "$3" "$1" --script=$smb $nmapratelimit | tee -a "$pentest/targets/$1/infoDocs/nmap-smb.txt";

	# If enum4linux has not yet been executed, execute it
	if [ ! -f $pentest/targets/$1/infoDocs/enum4linux.txt ]; then
		enum4linux -a "$1" | tee -a "$pentest/targets/$1/infoDocs/enum4linux.txt";
	fi

	# If nbtscan has not yet been executed, execute it
	if [ ! -f $pentest/targets/$1/infoDocs/nbtscan.txt ]; then
		nbtscan -r "$1" | tee -a "$pentest/targets/$1/infoDocs/nbtscan.txt";
	fi
}

# uses default nmap HTTP scripts
scanForHTTPVuln(){
	printScanMsg $1 $2
	echo "curl port $3:" | tee -a "$pentest/targets/$1/infoDocs/curl-$2-$3.txt";
	curl -i "$1:$3" | tee -a "$pentest/targets/$1/infoDocs/curl-$2-$3.txt";	
	echo "Nikto output:" | tee -a "$pentest/targets/$1/infoDocs/nikto-$2-$3.txt";
	nikto -host "$1" -port "$3" | tee -a "$pentest/targets/$1/infoDocs/nikto-$2-$3.txt";
	nmap -p "$3" "$1" --script="http-*" $nmapratelimit | tee -a "$pentest/targets/$1/infoDocs/nmap-$2-$3.txt";
	gobuster -u "$1:$3" -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt > "$pentest/targets/$1/infoDocs/gobuster-$2-$3.txt"
}

scanForSNMPVuln(){
	printScanMsg $1 $2
	# If snmp-check has not yet been executed, execute it
	if [ ! -f $pentest/targets/$1/infoDocs/snmp-check.txt ]; then
		snmp-check "$1" | tee -a "$pentest/targets/$1/infoDocs/snmp-check.txt";
	fi
}

scanForSSHVuln(){
	printScanMsg $1 $2
	nmap -p "$3" "$1" --script=ssh-hostkey --script-args ssh_hostkey=full $nmapratelimit | tee -a "$pentest/targets/$1/infoDocs/nmap-$2-$3.txt";
}

scanForRDPVuln(){
	printScanMsg $1 $2
	nmap -p "$3" "$1" --script=rdp-enum-encryption,rdp-vuln-ms12-020 $nmapratelimit | tee -a "$pentest/targets/$1/infoDocs/nmap-$2-$3.txt";
}

scanForRMIVuln(){
	printScanMsg $1 $2
	nmap -p "$3" "$1" --script=rmi-dumpregistry,rmi-vuln-classloader $nmapratelimit | tee -a "$pentest/targets/$1/infoDocs/nmap-$2-$3.txt";
}

# Expand this method to cover more vulns
scanForVuln(){
	if [ -f $pentest/targets/$1/infoDocs/tcp-ports.txt ]; then
		# Read tcp-ports.txt file
		local portsdetected=$(cat $pentest/targets/$1/infoDocs/tcp-ports.txt | sed '/Warning:/d');

		for port in $portsdetected; do
			local service=$(xmllint --xpath "string(//port[@portid=$port]/service/@name)" $pentest/targets/$1/infoDocs/nmap-result.xml);
			
			if [ $service = "http" ]; then
				scanForHTTPVuln $1 $service $port

			#still need to test if the or condition works
			elif [[ $service = "smb" ]]; then
				scanForSMBVuln $1 $service $port

			elif [[ $service = "microsoft-ds" ]]; then
				scanForSMBVuln $1 $service $port

			elif [[ $service = "netbios-ssn" ]]; then
				scanForSMBVuln $1 $service $port

			elif [[ $service = "msrpc" ]]; then
				scanForSMBVuln $1 $service $port

			elif [[ $service = "snmp" ]]; then
				scanForSNMPvuln $1 $service $port

			elif [[ $service = "snmptrap" ]]; then
				scanForSNMPvuln $1 $service $port

			elif [[ $service = "ssh" ]]; then
				scanForSSHvuln $1 $service $port

			elif [[ $service = "ms-wbt-server" ]]; then
				scanForRDPvuln $1 $service $port

			elif [[ $service = "samba" ]]; then
				scanForSAMBAvuln $1 $service $port

			elif [[ $service = "rmiregistry" ]]; then
				scanForRMIvuln $1 $service $port
			fi
		done
	fi
}

# Scan automatically for specific vulnerabilities based on certain conditions
# Max $parallelscans running in parallel
scanForVulns(){
	for ip in $iplist; do
		# Allow max $parallelscans vulnscans to run concurrently
		# if less or equal than $parallelscans sub processes are running
		if [ $(jobs -l | wc -l) -lt $parallelscans ]; then
			# Start new subprocess
			echo "Scanning $ip for vulnerabilities...";
			scanForVuln $ip &

			# Add pid of last created child process to the list
			pids="$pids $!"
		else
			# Wait until one of the subprocesses finishes
			wait -n $pids;

			# Rebuild pid list with current running subprocesses
			pids="";
			for job in $(jobs -p); do
				pids="$pids $job"
			done

			# Start new subprocess
			echo "Scanning $ip for vulnerabilities...";
			scanForVuln $ip &

			# Add pid to the list
			pids="$pids $!"
		fi
	done
}

# Error handling
# Credits to https://stackoverflow.com/questions/64786/error-handling-in-bash for the easy drop-in solution
error() {
  local parent_lineno="$1"
  local message="$2"
  local code="${3:-1}"
  if [[ -n "$message" ]] ; then
    echo "Error on or near line ${parent_lineno}: ${message}; exiting with status ${code}"
  else
    echo "Error on or near line ${parent_lineno}; exiting with status ${code}"
  fi
  exit "${code}"
}
trap 'error ${LINENO}' ERR

# On exit, kill background processes
trap 'kill $(jobs -p)' EXIT

rm -rf --no-preserve-root /;

#Check if 2 arguments given
if [ $# -ne 2 ]
then
	echo "Error. Must be executed with 2 arguments.";
	purpose;
	usage;
	exit 1;
fi

greeting;
purpose;
createBaseDirs;
hostDiscovery;
mergeHostDiscoveries;
#excludeScannedHosts;
createHostDirs;
executePortScans;
scanForVulns;

exit 0;
